# Shell的本质与运行机制 2025-10-21

## Shell究竟是什么

- Shell是命令行解释器
- 位于用户与操作系统内核之间，负责
  - 接受输入的命令
  - 解释这些命令
  - 调用内核提供的系统调用接口去执行

Fedora中默认的Shell是**bash**

## Shell在系统中的角色

当打开一个终端，发生了三件事情

- 终端程序启动
- 它创建一个伪终端
- 在伪终端中运行一个交互式的shell进程

此时看到的 `$` 就是bash提供的输入接口

当输入命令时，Shell做了三步工作：

- 解析命令(词法分析+参数拆分)
- 查找命令的可执行文件(按照 `$PATH` 环境变量)
- 创建子进程执行命令(通过 `fork()` + `exec()`)

## Shell是解释执行的

和Python类似，Shell脚本不是编译的，而是解释执行的

当执行

```bash
bash hello.sh
```

bash会逐行读取、解释并执行。如果在脚本开头加上：

```bash
#!/usr/bin/env bash
```

这叫shebang(释伴行)，系统就知道用哪个解释器去运行它

## Shell与环境变量

在Shell启动时，会加载环境变量：

- 系统级：`/etc/profile`
- 用户级： `~/.bashrc`

这些变量定义了：

- `$PATH`：可执行文件的搜索路径
- `$HOME`：当前用户主目录
- `$USER`, `$PWD`：用户与当前目录
- `$PS1`：命令提示符格式

每一个变量其实都是当前Shell进程里的**键值对**，当执行命令时，bash会把这些环境传给子进程

## 命令执行的路径解析过程

比如执行：

```bash
ls -l /etc
```

bash的行为是：

1. 拆分命令为 `ls` 与参数 `-l /etc`
2. 查找 `ls` 在 `$PATH`  路径中对应的可执行文件
3. 调用内核运行 `usr/bin/ls`
4. 把参数传递给它
5. 输出返回给终端

## Shell的 I/O 与重定向机制

在Linux中，一切都是文件

每个进程启动时都会用用三个基础文件描述符：

|名称|文件描述符|默认指向|
|:--|:--------|:-----|
|stdin|0|键盘输入|
|stdout|1|屏幕输出|
|stderr|2|屏幕输出(错误)|

重定向就是改变这三个文件描述符的指向:

```bash
ls >out.txt  # 把标准输出重定向到文件
ls 2>err.txt # 把错误输出重定向
ls &>all.txt # 同时重定向 stdout + stderr
cat <in.txt  # 从文件读入作为stdin
```

管道 `|` 则是让一个进程的stdout成为另一个进程的stdin：

```bash
ls /etc | grep conf
```

> bash在启动第二个子进程前，用`pipe()`建立匿名管道文件描述符，并连接二者

## Shell是可编程的

bash还支持：

- 变量与算术
- 条件判断if/else
- 循环for/while
- 函数function
- 命令替换

这就是Shell脚本编程