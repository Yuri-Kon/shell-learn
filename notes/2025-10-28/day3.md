# Shell的语言结构与变量机制 2025-10-28

## Shell语言的核心特征

shell的根本理念：

- 解释执行：shell脚本不是编译的，而是一行行解释
- 命令驱动：每一行就是一个命令调用
- 字符串为中心：变量没有类型，所有值都是字符串
- 空间分隔：参数依靠空格分隔，空格意义重大
- 子进程执行：绝大多数命令在子进程中运行

## 变量的定义与使用

### 定义与引用

```bash
name="Yurikon"
echo ${name}
```

注意：

- 等号两边不能有空格
- shell只有字符串类型，没有`int`/`float`

命名规范：

- 只能有字母、数字、下划线；
- 不可以用数字开头
- 建议局部变量小写，全局/环境变量大写(例如`$PATH`、`$HOME`)

### 变量替换与默认值

|形式|作用|示例|
|:--|:---|:---|
|`${var}`|基本引用|`echo ${name}`|
|`${var:-default}`|若未定义或者为空，则使用默认值|`echo ${user:-guest}`|
|`${var:=default}`|若未定义则设置为默认并使用|`${name:=guest}`|
|`${var:+alt}`|若已定义则替换为alt|`${PATH:+hashpath}`|
|`${#var}`|变量长度|`echo ${#name}`|

## 变量的生命周期

### 普通变量(Shell进程内的局部变量)

```bash
name="yurikon"
```

- 仅在**当前shell**进程中存在
- 当关闭当前shell进程后，这个变量就会销毁
- 不会自动继承给子进程(即不会传递给脚本、命令或子shell)

示例：

```bash
name="yurikon"
bash -c 'echo $name'   # 输出为空，因为子 shell 看不到父 shell 的变量
```

### 环境变量(export导出的变量)

```bash
export name="yurikon"
```

- 在当前shell进程及所有子进程中都有效
- 在关闭当前shell后，变量消失
- 子进程可以继承父进程的环境变量副本
  - 子进程继承的是父进程的变量的**副本**，对于子进程中该变量的修改不会影响到父进程

### 局部变量(函数内local变量)

```bash
myfunc() {
    local name="yurikon"
    echo "inside ${name}"
}
myfunc
echo "outside: ${name}" # 输出为空
```

- 只在函数执行期间存在
- 当函数执行完毕，局部变量就会立即销毁
- 不影响同名的全局变量

### 特殊情况：配置文件永久保存

如果希望每次打开shell时都存在，可以写入配置文件：

|使用场景|配置文件路径|说明|
|:-----|:----------|:---|
|当前用户|`~/.bashrc`或`~/.bash_profile`|每次登陆/打开终端都会加载|
|全局|`/etc/profile`或`/etc/bashrc`|对所有用户有效

## 引号机制与命令替换

### 引号的三种语义

- 无引号：变量会展开，空格分隔
- 单引号`'`：原样输出，不展开
- 双引号`"`：允许变量与命令展开
- 反斜杠`\`：转义紧跟在其后的单个字符的特殊语义
  - 在双引号内仅对`\"`, `\$`,\` 、\\、\n 生效，在单引号内不生效

```bash
USER="yuki"
echo 'User is $USER'   # 输出 User is $USER
echo "User is $USER"   # 输出 User is yuki
```

### 命令替换

#### 基本概念与作用

命令替换能够在命令中嵌套另一个命令的输出，从而实现“命令的结果再参与计算或输出”

例如：
```bash
命令1 $(命令2)
```
Shell会：

1. 先执行“命令2”
2. 把它的结果捕获下来
3. 替换到原来的位置
4. 再执行整个命令1

```bash
now=$(date +%F)
echo "Today is $now"
```

#### 语法形式

```bash
$(command)
```

例如：
```bash
echo "today is $(date)"
```
这里会先执行`date`这个命令，得到输出后再替换会原命令中的位置，再执行`echo`。

#### 执行顺序

执行流程可以分为四步理解：

1. Shell读到`$()`结构
2. 执行里面的命令
3. 获取其标准输出(不包括错误输出)
4. 把输出结果用作外层命令的参数，再执行外层命令

示例：
```bash
echo "当前路径是: $(pwd)"
```
执行顺序：
|步骤|内容|
|:---|:---|
|1|识别`$()`语法结构|
|2|执行`pwd`命令|
|3|获取其输出`/home/user`|
|4|替换并执行`echo "当前路径是: /home/user"`|

#### 命令替换的典型用途

**将命令结果赋值给变量**
```bash
today=$(date +%F)
echo "Today is $today"
```

**嵌套命令使用**
```bash
echo "文件个数: $(ls | wc -l)"
```

执行顺序：

1. `ls`：输出文件名
2. `wc -l`: 统计行数
3. 最终显示文件数

**路径、文件名动态化**

```bash
tar -czf backup-$(date +%Y%m%d).tar.gz mydata/
```

自动生成`backup-20251111.tar.gz`

**复杂嵌套**
```bash
echo $(echo $(echo 123))
```

最内层的`echo 123`先输出123,再逐层替换

#### 命令替换与引号的关系

|写法|含义|
|:---|:---|
|`echo $(ls)`|展开成一行字符串，多个文件名之间用空格分割|
|`echo "$(ls)"`|整体作为一串文本保留换行符|
|`files=$(ls)`|捕获输出结果，换行会转化为空格|
|`files="$(ls)"`|捕获原始输出，保留换行符|

#### 命令替换与重定向的区别

|概念|功能|举例|
|:--|:---|:----|
|命令替换|捕获命令输出作为字符串使用|`var=$(date)`|
|输出重定向|把输出写入文件|`date > time.txt`|

命令替换是“拿结果用”，重定向是“把结果存”。

#### 注意事项

1. **仅捕获标准输出，不包括错误输出**
    如果希望捕获错误，也可以用`output=$(command 2>&1)`
2. 去掉末尾换行符：命令替换结果的末尾换行符会被删除，除非用引号包裹
3. 性能与嵌套：每次命令替换都会新建一个子进程执行命令，因此嵌套太多会降低性能

#### 例子

```bash
a=$(expr 3+2)
b=$(ls | wc -l)
c=$(cat $(ls | grep.txt))
```

语义展开后是：

1. `exper 3 + 2`->输出5->`a=5`
2. `ls | wc -l` -> 统计当前文件数 -> `b=数量`
3. `ls | grep .txt` -> 匹配出文件 -> `cat 文件们`

命令替换就是Bash在语法层面实现“把命令结果当成数据”的方式

## 算术与字符串操作

### 算术扩展

#### 基本语法形式
```bash
a=5
b=3
echo $((a+b))
```
这是算术扩展的基本语法形式，语法为：
```bash
$((表达式))
```
这表示：
> 让shell把`(())`中的内容当作一个算术表达式计算，并返回结果

#### 与普通变量取值的区别

|写法|含义|
|:---|:---|
|`$a`|取变量a的值|
|`$((a+b))`|计算表达式a+b的值|
|`$((a*b+2))`|计算算术表达式|

这里的`((...))`整体是一个语法结构，并不是`$`后面加一个变量名。

#### 语法角度分析

1. `$(())`是一个**命令替换/值替换**语法
2. Shell在执行时，会先：
    - 解析`(())`内的表达式
    - 自动用变量的值替换变量名
    - 计算出结果
    - 把结果替换为`$(())`的位置
3. 最后`echo`再输出这个结果

### 字符串操作

```bash
str="abcdef"
echo ${str:2:3} # cde
echo ${str#abc} # def
echo ${str%def} # abc 
echo ${str/abc/xyz} # 替换一次
```

#### 字符串的本质

在Shell中：

```bash
a="hello"
```
这里的`a`就是一个字符串变量。Bash不区分数据类型，所有数据默认为字符串，只有在算术扩展`$(())`中才当作数字处理。

#### 字符串的基本操作

**获取字符串长度**

```bash
str="hello world"
echo ${#str} # 输出11
```

> `${#变量名}`表示“获取变量内容的长度”

**截取字串**

```bash
str="abcdefg"
echo ${str:2:3} # 从第三个字符开始取三个——cde 
```

语法：

```bash
${var(变量名):offset(起始位置):length(长度)}
```

注意：下标从0开始。如果省略长度，则截取到结尾：`${str:2}`——cdefg

如果索引是负数，则从末尾截取，注意负号与冒号之间要有空格：

```bash
echo ${str: -3} # efg
echo ${str: -3:2} # ef
```

负数索引中，最后一位字符是“-1”。

如果长度是负数，那么含义就是**截取时保留到字符串末尾前|length|个字符之前**，也就是**“截掉最后几位”**

比如：

```bash
echo ${str:0:-2} # abcde
```

- 从索引0开始；
- 长度为-2,意味着保留到倒数第二个字符之前；
- 因此结果是“abcde”

注意：不支持索引和长度同时为负数

**删除前缀/后缀（基于通配符）**

|操作|语法|含义|
|:---|:--|:-----|
|删除最短前缀匹配|`${var#pattern}`|从左边删除匹配`pattern`的最短部分|
|删除最长前缀匹配|`${vat##pattern}`|从左边删除匹配`pattern`的最长部分|
|删除最短后缀匹配|`${var%pattern}`|从右边删除匹配`pattern`的最短部分|
|删除最长后缀匹配|`${var%%pattern}`|从右边删除匹配`pattern`的最长部分|

例：

```bash
path="/usr/local/bin/script.sh"
echo ${path#*/} # 删除左边第一个“/”和左侧的—— usr/local/bin/script.sh
echo ${path##*/} # 删除左边最后一个“/”及左侧—— script.sh
echo ${path%/*} # 删除右侧第一个“/”及右边的部分—— /usr/local/bin
echo ${path%%/*} # 删除第一个“/”及右侧部分—— 空
```


