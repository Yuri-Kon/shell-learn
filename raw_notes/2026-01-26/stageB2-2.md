# B2: 变量、参数与引用规则——Shell的表达语义

**B2的总体目标**:

- 精确控制变量展开行为
- 明确什么时候必须加引号
- 正确处理包含空格、换行、通配符的参数
- 写出对用户输入不脆弱的脚本
- 理解 `$@`, `$*`, `$#`, `$?`等设计动机

______________________________________________________________________

## B2-2: 位置参数与参数传递的语义模型

本小节的目的是在任何情况下都能判断 **参数会以什么形式被传递、展开、拆分**。

______________________________________________________________________

### B2-2.1: 位置参数的概念: Shell的argv

在脚本内部或函数体内部，Shell用 "位置参数(position paramters)"来表示当前这层调用传进来的参数列表。

可以类比为C程序的`argv[0]...argv[n]`, 在bash中对应为:

- `$0`: 命令名或脚本名
- `$1`: 第一个参数
- `$2`: 第二个参数
- ...
- `${10}`: 第十个参数(必须用大括号，否则 `$1` 后面接0会被解释为 `${1}0`)

位置参数在Shell内部是一组有序列表，这组列表在两个场景中被设定:

1. 启动脚本时: `bash script.sh arg1 arg2`
   此时脚本内部 `$0` 是 `script.sh`(或者包含路径的脚本名)， `$1` 是 `arg1`, 以此类推。
1. 函数调用时: `my_func arg1 arg2`
   函数体内部的 `$1`, `$2` 指向的是函数调用处传入的参数，与脚本外层的 `$1`, `$2` 分离。可以理解为每次进入函数时建立一组新的 "局部argv"

这意味着，在函数内使用 `$1`, `$2` 等不会干扰脚本最外层的参数解释，函数返回后，外层的 `$1`, `$2` 会自动恢复。

______________________________________________________________________

### B2-2.2: `$0` 与 `$1` ... `$n` 的区别

`$0` 经常被忽略，但对写 CLI 工具很重要。

- 在脚本中，`$0` 通常是该脚本的路径。可能是相对路径 `./script.sh`, 也可能是绝对路径，取决于调用方式。
- 在交互式 bash 中，`$0` 通常是 bash 或 `-bash`(有时带一个 `-`，表示登录Shell)
- 在函数内，`$0` 仍然保持外层调用的值，并不会变成函数名。

典型用途：在脚本里构建 "自描述用法" 或 "错误提示" 时会写:

```bash
usage() {
   echo "Usage: $0 [-h] [-o OUTPUT] input_file"
}
```

这样用户看到的命令名就会自动和实际调用的一致

______________________________________________________________________

### B2-2.3: 如何设定位置参数: 脚本调用与 `set`

刚才讲的是 "默认来源", 但是在脚本内部也可以通过 `set` 命令重置位置参数。

```bash
set -- "a" "b" "c"
echo "$1"  # a
echo "$2"  # b
echo "$3"  # c
```

`set -- ` 的语义是：丢弃原有参数列表，并用后面的内容重新构建 `$1, $2 ... $n`, 这样在写解析命令输出时偶尔会用到。比如把一行字符串拆成位置参数以方便处理。

> 注意: `set`会修改当前Shell的位置参数，因此在函数内部使用时要有意识地考虑是否需要 **在结束前恢复** , 例如先保存 `$@`, 结束后再用 `set -- $@` 恢复。

______________________________________________________________________

### B2-2.4: `$#` 当前参数个数

`$#` 表示当前这组位置参数的数量. 含义类似C语言中的 argc, 但是不包括 `$0`.

在脚本顶层:

- 如果脚本是 `script.sh arg1 arg2` 启动的, 则 `$#` 为2
- 在函数内部, `$#` 表示函数接收到的参数个数.

常见用法是参数检查:

```bash
if [ "$#" -lt 1 ]; then
   echo "Missing arguments" >& 2
   exit 1
fi
```

上面这段在脚本和函数中都合法, 语义完全一致: 检查当前这层调用是否至少提供了一个参数.

______________________________________________________________________

### B2-2.5 `"$@"` 和 `"$*"` 的精确语义

严格区分四类语法:

- `$@`
- `$*`
- `"$@"`
- `"$*"`

关键在于:

- 是否加双引号
- 内部是否按 IFS 拆分

先写一个固定前提, 便于对比:

```bash
set -- "arg1" "arg 2" "arg3"
```

现在的 `$1` 是 arg1，`$2` 是 arg 2, `$3` 是 arg3

#### 不加引号的 `$@` 与 `$*`

```bash
for x in $@; do ...; done
for x in $*; do ...; done
```

在默认 IFS 下，两者效果相同：将所有参数按空白拆开后逐个遍历。\
由于位置参数本身已经是按照参数划分的，拆分效果在常规效果下是等价的，但是一旦参数中**本身含有空格**，就会出现问题。

上述 `set --` 的情况下:

- `$@` 展开为: `arg1` `arg` `2` `arg3`
- `$*` 展开为: `arg1` `arg` `2` `arg3`

两个都把 `arg 2` 拆成了两个单词。

#### 加引号的 `"$@"`

`"@"`的表现可以精确描述为:

> 把当前的每一个位置参数原样作为一个独立的单元展开, 保持参数边界不变

所以在刚才的前提下, 依旧是 `"arg1" "arg 2" "arg3"` 这三个参数:

```bash
`printf '<%s>\n' "$@"`
```

等价于依次执行:

```bash
printf '<%s>\n' "arg1"
printf '<%s>\n' "arg 2"
printf '<%s>\n' "arg3"
```

这是传参过程中最安全的用法, 也是Shell编写中建议的写法. 在函数中转发所有参数时, 推荐:

```bash
some_func() {
   other_func "$@"
}
```

#### 加引号的 `"$*"`

`"$*"` 的行为可以表述为:

> 把所有位置参数连接成一个字符串, 中间插入 `IFS` 的第一个字符, 然后整体作为一个参数

在默认 `IFS` 为空格的情况下, "形如把所有参数用空格拼成一行再当作一个参数"

在刚才的前提下:

```bash
printf '<%s>\n' "$*"
```

只会输出一行 `<arg1 arg 2 arg3>`, 这是一个单独的参数

这个特性在脚本中不常用, 除非确实想把 "原本是多个参数" 的东西合并成一个字符串去处理.

#### 总结 `"$@"` 与 `"$*"`

- `"$@"`: 保持参数列表原样不变, 逐个传递, 非常适合 "参数转发"
- `"$*"`: 把所有参数拼接成一个字符串, 整体当作一个参数, 多用于构造消息或日志, 而不是用于继续执行子命令.

______________________________________________________________________

### B2-2.6. `shift`: 向前移动参数视窗

`shift` 是处理参数位置时的另一个工具. 它的作用是: 丢弃最前面的若干参数, 将后面的参数整体向前平移.

如果当前参数是:

- `$1` -> A
- `$2` -> B
- `$3` -> C

执行 `shift` 后:

- `$1` -> B
- `$2` -> C
- `$#` 从3变成2

这对于实现手写参数解析十分常见, 例如:

```bash
while [[ "$#" -gt 0 ]]; do
   case "$1" in
      -o|--output)
         output="$2"
         shift 2
         ;;
      -h|--help)
         show_help
         exit 0
         ;;
      *)
         echo "Unknown option": $1 >&2
         exit 1
         ;;
   esac
done
```

这里的逻辑可以在抽象层面理解为: `$1` 是 "当前处理的选项", `shift` 是把视窗向后滑动, 直到处理完所有参数

`shift n` 中的 `n` 可以指定丢弃的参数数量, 默认是1. 必须保证 `n <= $#`, 否则会报错

______________________________________________________________________

### B2-2.7. 常用特殊参数: `$?`, `$$`, `$!`, `$_`

这些虽然不是 "位置参数", 但是也关系密切, 因此一起放在 B2-2 中说明.

#### `$?`: 上一条命令的退出状态 (exit status)

Shell 中每条命令执行完都会设置一个整数状态码, 约定俗称是:

- 0 表示成功
- 非 0 表示某种错误, 不同命令内部自己定义含义

`$?` 的值总是指向最后一条命令的退出状态.

例如:

```bash
cp source dest
status=$?
if [[ "$status" -ne 0 ]]; then
   echo "Copy failed with status $status" >&2
fi
```

#### `$$`: 当前Shell进程的PID

- 在脚本或交互式Shell中, `$$` 给出当前Shell的PID
- 子Shell中的`$$` 不同于父进程

典型用途包括生成临时文件名: `tmp/myapp.$$`

#### `$!`: 最近一个后台任务PID

当执行:

```bash
long_task &
echo "PID is $!"
```

`$!` 会保存刚启动那个后台进程的PID, 可以用于后续 `wait $!` 或监控.

#### `$_`: 上一个命令的最后一个参数

这是一个比较冷门但有时很实用的参数. 例子:

```bash
echo a b c
echo "$_"
```

第二条会输出 `c`. 在交互式用法中, 常见模式是:

```bash
mkdir newdir
cd $_
```

写脚本时不太推荐大量使用, 因为可读性会下降. 但了解其存在有助于读懂别人的脚本.

### B2-2.8. 脚本设计层面的几条稳定约定

结合前面所有内容, 可以抽象出几条工程向规范:

1. 函数内部转发参数时, 默认使用 `"$@"`

例如:

```bash
run_task() {
   inner_run "$@"
}
```

这样不更改参数边界.

2. 编写CLI工具时, 应当在入口处检查 `$#`

至少保证基础形态是:

```bash
if [[ "$#" -lt 1 ]]; then
   usage >$2
   exit 1
fi
```

3. 构造错误信息时, 有意识保留 `$?`

不要在赋值前调用其他命令, 否则 `$?` 会被覆盖.

4. 遍历参数列表, 优先使用 `while + shift` 或 `for arg in "$@"`
   全程保持引用规则一致, 避免在中途忘记加引号.

### B2-2.9. 小结

位置参数是当前调用环境的 `argv`; `$#` 是参数个数; `$1...$n` 是有序列表.\
`"$@"` 表示 "原样地逐个传递当前参数列表", 适合作为参数转发时的默认选项.\
`"$*"` 表示 "把当前参数列表拼接为一个字符串", 适合作为日志或信息输出的构造工具, 而不是继续传递给其他命令.\
`$?` 承接上一个命令的退出状态, 是错误处理和健壮性设计的基础.
