# 阶段B：Shell脚本的执行模型、结构化设计

**学习目标**:

- 能够清楚解释Shell脚本时如何被执行的
  shebang、解释器、命令逐行启动。当前Shell、子Shell、source的执行能力差异等
- 可以独立设计一个结构清晰的Shell脚本
- 理解Shell中变量、参数、引用与环境的真实规则
  引号的添加时机、`$@`与`$*`的差异来源、export的边界以及环境环境变量如何跨进程传播
- 写出具备基本健壮性的脚本
- Shell 的适用边界

______________________________________________________________________

## B1: Shell 脚本的执行模型与生命周期

这一节的核心任务是：

> 理解 一行文本从文件到执行结果，中间发生了什么

**B1的学习目标**

学习完B1, 需要能够做到:

- 解释Shell 脚本的执行流程
- 明确三种运行脚本方式的本质差异
- 理解 shebang 在 Fedora 下的解析机制
- 通过进程视角判断 是不是同一个Shell
- 通过实验验证变量、环境的存活与消失

______________________________________________________________________

## B1-2: 当前Shell、子Shell与环境边界

这一节会系统解决以下问题:

- 为什么变量在脚本里有，在脚本外面没有
- `export` 到底改变了什么
- 环境变量如何 "向下传播" 的
- 子 Shell 能不能反向影响父 Shell
- 为什么cd在脚本里经常 "没用"

这些是变量、参数、配置文件的理论基础

______________________________________________________________________

### B1-2.1: 什么是 "当前 Shell"

现在终端里正在交互的进程，就是 "当前 Shell"

可以用

```bash
echo $$
```

确认它的 PID。

只要没有显式启用新的 Shell, 这个PID就不会改变。Shell的当前环境指的就是:
**这个进程内部维护的一整套状态**，包括：

- 当前工作目录
- 变量与函数
- 已导出的环境变量
- shell 选项(set)

______________________________________________________________________

### B1-2.2: 子 Shell 如何出现的

只要发生了下面任意一种情况，就会出现子 Shell：

- 执行 `bash、sh`
- 运行脚本: `bash script.sh`
- 运行可执行脚本: `./script.sh`
- 使用管道: cmd1 | cmd2(右侧命令在子进程)

子Shell 的特点:

> **它能继承父 Shell 的一部分环境，但是无法反向修改父Shell**

______________________________________________________________________

### B1-2.3: 变量为什么会"消失"

在当前shell中执行:

```bash
foo=hello
```

再写一个脚本`print.sh`:

```bash
#!/usr/bin/env bash
echo "$foo"
```

执行:

```bash
bash print.sh
```

会发现什么都不打印.\
因为普通Shell变量默认只存在于当前进程.

______________________________________________________________________

### B1-2.4: `export` 的真实含义

如果在当前shell中执行:

```bash
export foo=hello
```

再执行脚本:

```bash
bash print.sh
```

这次就能打印出来了.\
因为 `export` 并不是变成 "全局变量", 而是:

> 把变量放进"环境变量表", 供子进程复制一份

这里子进程拿到的是副本, 而不是引用. 因此子进程中对于`export`变量的修改无法影响父进程

______________________________________________________________________

### B1-2.5: 为什么子Shell修改不了父Shell

做这个实验:

```bash
#!/usr/bin/env bash
foo=child
export bar=child
cd /
```

在当前Shell:

```bash
foo=parent
export bar=parent
pwd
bash child.sh
echo "$foo"
echo "$bar"
pwd
```

结果是:

- `foo` 仍然是parent
- `bar` 仍然是parent
- 当前目录不变.

即: **子进程推出时, 整个进程空间都会被内核销毁**.\
因此其做过的修改没有任何机会回写

______________________________________________________________________

### B1-2.6: 为什么 `source` 能修改环境

因为脚本 **根本没有进入子进程**, 而是在 **当前shell** 里逐行执行.

______________________________________________________________________

### B1-2.7: 边界认知

> Shell 的环境传播方向是:\
> 父进程 -> 子进程\
> 没有任何机制支持 子进程 -> 父进程\\

所以虚拟环境必须用 `source .../activate`, 配置文件不能用 `bash config.sh`, 脚本不能直接修改终端状态.

______________________________________________________________________

### B1-2.8: 日常使用的关联

在 Fedora/Pop!\_OS的使用中, 已经在使用过这些规则了:

- `bashrc`/`.zshrc`是被source的
- `conda activate`/`python -m venv`也是source的
- `export PATH=...`只对当前会话和子进程有效
- systemd service 拿到的是"干净环境"
