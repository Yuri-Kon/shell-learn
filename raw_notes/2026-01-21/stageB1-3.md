# 阶段B：Shell脚本的执行模型、结构化设计

**学习目标**:

- 能够清楚解释Shell脚本时如何被执行的
  shebang、解释器、命令逐行启动。当前Shell、子Shell、source的执行能力差异等
- 可以独立设计一个结构清晰的Shell脚本
- 理解Shell中变量、参数、引用与环境的真实规则
  引号的添加时机、`$@`与`$*`的差异来源、export的边界以及环境环境变量如何跨进程传播
- 写出具备基本健壮性的脚本
- Shell 的适用边界

______________________________________________________________________

## B1: Shell 脚本的执行模型与生命周期

这一节的核心任务是：

> 理解 一行文本从文件到执行结果，中间发生了什么

**B1的学习目标**

学习完B1, 需要能够做到:

- 解释Shell 脚本的执行流程
- 明确三种运行脚本方式的本质差异
- 理解 shebang 在 Fedora 下的解析机制
- 通过进程视角判断 是不是同一个Shell
- 通过实验验证变量、环境的存活与消失

______________________________________________________________________

## B1-3: Shell初始化流程与配置文件加载顺序

这一节的目的是:\
解决这个问题: 配置文件什么时候被读?

首先站在Unit/Linux通用模型上, 再解释Fedora/Debian/Arch等发行版的策略差异.

______________________________________________________________________

### B1-3.1: 从Unit的基本假设开始

在Unit传统中,有三个十分重要的设计前提:

第一, Shell 是一个普通进程.\
它启动时, 只能读取文件, 设置自身状态, 然后进入交互或执行模式

第二, Shell 的"使用方式"不同, 初始化需求也不同.\
有的Shell用来登陆系统, 有的用来执行脚本, 有的只是打开一个终端.

第三, 配置文件的存在是为了 **区分不同使用场景**.\
系统不希望每次启动Shell都做同样的事情.

因此, Unit并没有 "唯一配置文件", 而是一组 **按场景划分的初始化文件**.

______________________________________________________________________

### B1-3.2: 三个关键概念

在所有Linux/Unix系统中, Shell启动时都会被划分为三类场景.

#### 登陆Shell(login shell)

这是一个用户身份被确认后的起点. 典型场景包括:

- 通过tty登陆
- 通过ssh登陆
- 显式执行`bash --login`

这一类Shell的职责偏向建立用户环境.

#### 非登陆交互式Shell(interactive non-login)

用户已经登陆过, 只是又打开了一个Shell.

- 桌面环境里的终端模拟器
- `tmux`新窗口
- 图形界面下的shell tab

#### 非交互式Shell(non-interacitve)

Shell不与人交互, 只执行任务.

- 执行脚本
- systemd service
- `bash -c "cmd"`

这一类Shell几乎不读用户交互配置.

______________________________________________________________________

### B1-3.3: Bash 的标准加载顺序(通用规则)

这是bash在Linux上的标准行为, 与发行版无关.

______________________________________________________________________

#### 登陆Shell的加载顺序

当bash作为登陆Shell启动时:

1. `etc/profile`
1. 然后读取下面之一(按存在顺序):

- `~/.bash_profile`
- `~/.bash_login`
- `~/.profile`

读取到一个就停止

这一步的设计目标是: 建立一次性的用户会话环境.

#### 非登陆交互式Shell的加载顺序

当bash作为交互Shell启动但不是登陆Shell时:

1. `/etc/bashrc`(有些系统)
1. `~/.bashrc`

这就是最常接触, 最应该写alias/prompt的地方

#### 非交互式Shell的行为

默认情况下:

- 不会读取上述任何文件
- 只继承父进程导出的环境变量

只有在设置了 `BASH_ENV` 时, 才会额外 source 指定文件

______________________________________________________________________

### B1-3.4: 为什么 `.bashrc` 和 `.bash_profile/.profile/.bash_login` 要分开

这纯粹是一个设计问题.

`.profile` 的典型职责是:

- 设置PATH
- export 环境变量
- 启动一次性的会话组件

![Alt](./figure/01.png)

`.bashrc` 的典型职责是:

- alias
- prompt
- shell行为设置
- 补全, 快捷键

很多系统会在 `.profile`中手动 `source .bashrc`, 用来统一行为

![Alt](./figure/02.png)

______________________________________________________________________

### B1-3.5: 发行版层面的策略差异

以Fedora/Debian/Arch为例, 如何在这个模型上取舍的.

______________________________________________________________________

#### Fedora的策略

Fedora更偏向 "桌面与系统一致性"

特点是:

- 桌面环境通常不通过登陆Shell启动
- 图形会话的环境变量更多由systemd管理
- 终端几乎总是非登陆交互式Shell

结果就是:

- `~/.bashrc` 是最稳定生效的位置
- `.bash_profile` 更多用于兼容传统登陆场景

______________________________________________________________________

#### Debian/Ubuntu系的策略

Debian 追求保守与兼容

特点是:

- 明确区分登陆与非登陆
- 提供 `etc/profile.d/`机制
- 用户层面强调 `.profile` 的通用性

在Debian系中,

- `.profile`往往是最 "保险" 的入口
- `.bashrc` 仍然用于交互行为

______________________________________________________________________

#### Arch Linux 的策略

Arch Linux 极简且不做假设.

特点是:

- 系统几乎从不做兜底
- 不默认source 任何多余文件
- 强调 "用户知道自己在做什么"

在 Arch 中:

- 配置文件加载行为非常 "原教旨"
- 配置文件写错地方真的就不生效
