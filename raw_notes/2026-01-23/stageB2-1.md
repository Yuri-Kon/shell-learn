# B2: 变量、参数与引用规则——Shell的表达语义

**B2的总体目标**:

- 精确控制变量展开行为
- 明确什么时候必须加引号
- 正确处理包含空格、换行、通配符的参数
- 写出对用户输入不脆弱的脚本
- 理解 `$@`, `$*`, `$#`, `$?`等设计动机

______________________________________________________________________

## B2-1: 变量展开与引用规则

______________________________________________________________________

### B2-1.1: Shell 执行一条命令时的整体流程

______________________________________________________________________

一行命令从敲下回车到真正执行，中间大致经历以下阶段:

1. **解析(parsing)**:
   Shell 把整行输入根据语法规则切成 "命令+参数+重定向" 等语法单元。这个阶段只根据**空白**和特殊符号(`;|&<>`等)进行语法分析，尚未进行变量替换
1. **各类展开(expansion)**:
   每一个语法单元内部，进行多种展开:

- 波浪线展开(tilde expansion): `~` -> `/home/xxx`
- 参数展开(parameter expansion): `$VAR`, `${VAR}`等
- 命令替换(command substitution): `$(cmd)`, `cmd`
- 算术展开(arithmetic expansion): `(( expr ))`

3. **单词拆分(word splitting)**:
   **展开完成后**，Shell会根据内部的词拆分规则(主要由变量 IFS 控制，默认是空格、换行、tab)把每个中间字符串拆成一个或多个 "参数单元"。\
   这一阶段对于未加引号的内容影响极大
1. **通配符匹配(pathname expansion / globbing)**:
   在完成单词拆分之后，包含 `*, ?, []` 的单元会用于匹配文件名。例如 `*.txt` 展开未当前目录下所有 `.txt` 文件的列表。
1. **执行(execution)**:
   最终得到的序列：\
   第一个单元作为命令名，后续单元作为 `argv[1...]` 传给该命令。此时变量的概念已经结束，只剩下纯字符串。

关键点在于：变量、命令替换、算术等所有展开是在执行前统一执行的。而 "是否加引号" 决定这些结果在后续阶段会不会被拆分、会不会参与通配符匹配

______________________________________________________________________

### B2-1.2: 参数展开(paramter expansion)的基本形式

先聚焦最核心的一类：参数/变量展开

最基本的形式有：`$VAR`, `${VAR}`

两者在很多情况下等价。推荐的严格写法是：只要变量名后面紧跟其他字符，就写成 `${VAR}xxx` 的形式，避免 Shell 把 VARxxx 误认为变量名。

参数展开本身只做 "字符串替换"，并没有单词拆分和通配符。这些是在后续阶段发生的。

示例:

```bash
name="hello world"
echo $name
```

执行流程是：

- 解析：`echo`和 `$name` 作为两个语法单元
- 参数展开：`$name` -> `hello world`
- 单词拆分：`hello world` 被拆分未两个参数 `hello` 和 `world`
- 执行: `echo` 收到两个参数

如果写成:

```bash
echo "$name"
```

则对于变量 `$name` 会被展开为 `hello world`, 但是在后续过程中，不会被单词拆分为两个参数，因为被 `""` 阻断。所以 `hello world` 被作为一个参数传递给 echo.

______________________________________________________________________

### B2-1.3: 引用(quoting) 的四种常见形式

Shell 中的 "引用(quoting)" 可以理解为:

> 引用决定某个字符串在后续阶段是否允许拆分、是否允许通配符匹配、哪些展开还继续发生

#### 常见的四种写法

1. 不加引号(unquoted)

- 所有展开都会发生
- 展开结果会参与单词拆分
- 展开结果会参与通配符匹配

2. 单引号: `'...'`

- 内容视为纯文本
- 里面几乎没有任何展开: `$, "", *` 等特殊字符都失去特殊意义
- 不能在单引号内嵌套单引号

3. 双引号: `"..."`

- 仍然允许参数展开、命令替换、算数展开
- **阻断单词拆分**：展开结果整体仍视为一个单元
- 阻断通配符匹配：`*, ?` 等都是普通字符

4. 反斜杠: `\`

- 单独转义紧跟随其后的一个字符
- 常用于在未加整体引号时保留某个符号的字面含义

______________________________________________________________________

### B2-1.4: 不加引号时的问题: 拆分与通配

考虑变量值中包含空格、换行、通配符的情况，这是脚本中最常见的风险源。

#### 例1：路径中有空格

```bash
file="My Document.txt"
cat $file
```

执行时：

- 展开: `$file` -> `My Document.txt`
- 拆分: 以空格拆分 My 和 Document.txt
- 执行: `cat` 收到两个参数，表现为两个文件名

这样就会行为失真。本意是打开 `My Document.txt` 这一个文件，但是执行结果却是 `cat` 尝试打开 `My` 和 `Document.txt` 两个文件。

正确写法应该是:

```bash
cat "$file"
```

这里的双引号能够保证参数展开仍然有效，但是其展开结果被视为一个整体，不会进行拆分和通配。

#### 例2：变量中不小心引入通配符

```bash
pattern="*.txt"
echo $pattern
```

如果当前目录中包含多个 `.txt` 文件，输出将是这些文件名的列表，而不是期望输出的字面意义上的 `*.txt`。\
如果希望输出字面含义，可以写成:

```bash
echo "$pattern"
```

______________________________________________________________________

### B2-1.5: 单引号与双引号的精确比较

- 单引号: 完全屏蔽几乎所有特殊意义(仅保留结束引号的语法意义)，内容原样保留
- 双引号: 保留参数和命令替换的 "逻辑展开"，屏蔽单词拆分和通配符

具体到变量:

```bash
msg="world"

echo 'hello $msg'
# 输出 hello $msg
echo "hello $msg"
# 输出 hello world
```

如果想构造 "部分展开+部分字面" 的内容，可以组合使用，如:

```bash
echo "hello ${msg}_literal"
```

______________________________________________________________________

### B2-1.6: 命令替换与换行问题

命令替换 `$(...)` 在B2-4会系统讲解，这里只需要知道两件事情:

- 命令替换的结果也会经历拆分与通配。
  `files=$(ls)` 之后，`echo $files` 会按空格和换行拆分。`echo "$files"` 会保留整体。
- 换行在拆分阶段会被是为分隔符。
  对于包含换行的参数，若不加引号，通常无法保留其换行结构。这在处理输出列表是十分敏感

因此，一个基本习惯是：

对于命令替换的结果，只要想保留整体结构，就默认用双括号包裹:

```bash
result=$(command)
echo "$result"
```

______________________________________________________________________

### B2-1.7: 决策原则

根据上述的执行流程，可以给出一套偏工程化的决策原则:

1. 拿不准时，优先加双引号
   - 几乎所有参数形式 `"$VAR"`都是安全默认的
   - 不加引号通常是 "确实希望拆分或通配" 的情况
1. 遇到路径、文件名、用户输入，一律加双引号
   - 这些内容最易包含空格、特殊符号
   - 文件名中可能出现通配符
1. 需要保留字面意义时使用单引号
   - 比如在脚本中只想输出 `$HOME` 这几个字
   - 或者要写正则表达式、复杂shell片段
1. 只有非常清楚 "需要拆分" 时，才故意不加引号
   - 例如希望用户通过变量传入多参数: `set -- $USER_INPUT`
   - 此时这里是一次 "有意的拆分"

______________________________________________________________________

### B2-1.8: 小实验

#### 空格实验

- `name="hello world"`
- 分别执行: `printf '<%s>\n' $name`, `printf '<%s>\n' "$name"`
- 观察参数数量差异

#### 通配符实验

- `pattern="*.sh"`
- 在所有有 .sh文件的目录下比较 `echo $pattern` 与 `echo "$pattern"`

______________________________________________________________________

### B2-1.9: 小结

B2-1的核心在于:

一条命令在执行前会经历 "解析 -> 各类展开 -> 单词拆分 -> 通配符匹配 -> 执行" 的流水线。\
变量展开本身只是把标记替换为字符串，真正改变参数结构的阶段是 "拆分" 和 "通配"。\
各种引号和转义手段控制的是 "哪些内容参与这些阶段，哪些内容整体保留"。
